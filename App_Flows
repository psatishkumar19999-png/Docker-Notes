+-------------+
| Source Code |
| (Developer) |
+-------------+
        |
        v
+-------------+
|  Artifact   |
| (JAR/Binary)|
+-------------+
        |
        v
+-------------+
| Dockerfile  |
+-------------+
        |
        v
+-------------+
| Docker Image|
+-------------+
        |
        v
+-------------+
|  Registry   |
+-------------+
        |
        v
+----------------------+
| Container (Host/VM)  |
| Application Running  |
+----------------------+


Explanation below:
Application Flow 

Source Code (Developer)
The developer writes application source code (Java, Node, Python, etc.).

Artifact
The source code is compiled or packaged into an artifact (for example: JAR, WAR, binary).
This artifact is the deployable output of the application.

Dockerfile
A Dockerfile defines how the application should run:

Base OS or runtime

Copy artifact

Install dependencies

Define startup process (CMD / ENTRYPOINT)

Docker Image
Using the Dockerfile, Docker builds an immutable image.
The image contains the application, runtime, libraries, and configuration.

Registry
The Docker image is pushed to a registry (Docker Hub, ECR, GCR, ACR).
This allows sharing and deployment across environments.

Container (Host)
The image is pulled from the registry and run as a container on a host machine.
The container runs the application process and serves traffic.


======================================================================================================
User
 |
 |  https://example.com
 v
DNS
 |
 v
Load Balancer
 |
 v
Ingress
 |
 v
Service (Port 80)
 |
 v
Container (Port 8080)
 |
 v
Application

Explanation:

1.User hits URL (example: 1279.com)
This is the public domain the user types in the browser.

2.DNS Map
DNS maps the domain name to the Load Balancer IP.

3.Load Balancer (LB)
LB receives the request from the internet and forwards it to Kubernetes.

4.Ingress
Ingress decides which service should receive the request based on rules (host/path).

5.Service
Service exposes the application inside the cluster and forwards traffic to pods.

6.Service Port: 80

Target Port: 8080

7.Container (inside Pod)
The actual application runs inside the container.

Application listens on 8080

Container runs the process
